import socket
import ipaddress
import concurrent.futures
from typing import List, Dict, Any, Optional
import subprocess
import json
import time
from .auth import AuthorizationManager

class NetworkScanner:
    """Network scanning functionality with authorization checks"""
    
    def __init__(self, auth_manager: AuthorizationManager):
        self.auth_manager = auth_manager
        self.max_threads = 50
        self.timeout = 2
        
    def discovery_scan(self, target: str) -> List[Dict[str, Any]]:
        """Perform host discovery scan"""
        results = []
        
        try:
            network = ipaddress.ip_network(target, strict=False)
            
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_threads) as executor:
                futures = []
                
                for ip in network:
                    if self.auth_manager.is_target_authorized(str(ip)):
                        future = executor.submit(self._check_host, str(ip))
                        futures.append((str(ip), future))
                
                for ip, future in futures:
                    try:
                        is_alive = future.result()
                        if is_alive:
                            results.append({
                                'ip': ip,
                                'status': 'alive',
                                'timestamp': time.time()
                            })
                    except Exception as e:
                        pass
                        
        except Exception as e:
            raise Exception(f"Discovery scan error: {str(e)}")
        
        return results
    
    def port_scan(self, target: str, port_range: str) -> List[Dict[str, Any]]:
        """Perform TCP port scan"""
        results = []
        
        if not self.auth_manager.is_target_authorized(target):
            raise Exception(f"Target {target} not authorized")
        
        start_port, end_port = self._parse_port_range(port_range)
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            futures = []
            
            for port in range(start_port, end_port + 1):
                future = executor.submit(self._check_port, target, port)
                futures.append((port, future))
            
            for port, future in futures:
                try:
                    is_open = future.result()
                    if is_open:
                        results.append({
                            'ip': target,
                            'port': port,
                            'state': 'open',
                            'protocol': 'tcp',
                            'timestamp': time.time()
                        })
                except Exception:
                    pass
        
        return results
    
    def service_scan(self, target: str, port_range: str) -> List[Dict[str, Any]]:
        """Perform service detection scan"""
        port_results = self.port_scan(target, port_range)
        results = []
        
        for port_info in port_results:
            service_info = self._detect_service(target, port_info['port'])
            port_info.update(service_info)
            results.append(port_info)
        
        return results
    
    def vulnerability_scan(self, target: str) -> List[Dict[str, Any]]:
        """Perform basic vulnerability assessment"""
        results = []
        
        common_vulns = [
            {'port': 21, 'service': 'ftp', 'check': 'anonymous_login'},
            {'port': 22, 'service': 'ssh', 'check': 'weak_cipher'},
            {'port': 23, 'service': 'telnet', 'check': 'unencrypted'},
            {'port': 445, 'service': 'smb', 'check': 'smb_signing'},
            {'port': 3389, 'service': 'rdp', 'check': 'nla_enabled'}
        ]
        
        for vuln in common_vulns:
            if self._check_port(target, vuln['port']):
                results.append({
                    'ip': target,
                    'port': vuln['port'],
                    'service': vuln['service'],
                    'vulnerability': vuln['check'],
                    'severity': 'medium',
                    'description': f"Potential {vuln['check']} vulnerability",
                    'timestamp': time.time()
                })
        
        return results
    
    def _check_host(self, ip: str) -> bool:
        """Check if host is alive using TCP connect"""
        common_ports = [80, 443, 22, 445, 3389]
        
        for port in common_ports:
            if self._check_port(ip, port):
                return True
        
        return False
    
    def _check_port(self, ip: str, port: int) -> bool:
        """Check if TCP port is open"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            result = sock.connect_ex((ip, port))
            sock.close()
            return result == 0
        except Exception:
            return False
    
    def _detect_service(self, ip: str, port: int) -> Dict[str, str]:
        """Basic service detection"""
        service_map = {
            21: 'ftp',
            22: 'ssh',
            23: 'telnet',
            25: 'smtp',
            53: 'dns',
            80: 'http',
            110: 'pop3',
            143: 'imap',
            443: 'https',
            445: 'smb',
            3306: 'mysql',
            3389: 'rdp',
            5432: 'postgresql',
            8080: 'http-alt'
        }
        
        service = service_map.get(port, 'unknown')
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            sock.connect((ip, port))
            sock.send(b'HEAD / HTTP/1.0\\r\\n\\r\\n')
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            if banner:
                return {
                    'service': service,
                    'banner': banner.strip()[:200]
                }
        except Exception:
            pass
        
        return {'service': service}
    
    def _parse_port_range(self, port_range: str) -> tuple:
        """Parse port range string"""
        if '-' in port_range:
            start, end = port_range.split('-')
            return int(start), int(end)
        else:
            port = int(port_range)
            return port, port